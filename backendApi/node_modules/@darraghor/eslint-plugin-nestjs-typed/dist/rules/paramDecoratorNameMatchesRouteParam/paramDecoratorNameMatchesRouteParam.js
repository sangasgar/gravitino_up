"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.shouldTrigger = exports.isParameterNameIncludedInAPathPart = exports.hasPathPartsAnyRegexParams = exports.parsePathParts = void 0;
/* eslint-disable unicorn/prevent-abbreviations */
const utils_1 = require("@typescript-eslint/utils");
const createRule_1 = require("../../utils/createRule");
const nestRequestMethodDecoratorNames = new Set([
    "Get",
    "Post",
    "Put",
    "Delete",
    "Patch",
    "Options",
    "Head",
    "All",
]);
const parsePathParts = (decorator) => {
    const decoratorArgument = decorator?.expression
        ?.arguments[0];
    if (decoratorArgument?.type === utils_1.TSESTree.AST_NODE_TYPES.TemplateLiteral ||
        decoratorArgument?.type === utils_1.TSESTree.AST_NODE_TYPES.Identifier) {
        return ["dareslint__skip"];
    }
    if (decoratorArgument?.type === utils_1.TSESTree.AST_NODE_TYPES.Literal) {
        return [decoratorArgument.raw];
    }
    if (decoratorArgument?.type === utils_1.TSESTree.AST_NODE_TYPES.ArrayExpression) {
        return decoratorArgument.elements.map((x) => x.raw);
    }
    if (decoratorArgument?.type === utils_1.TSESTree.AST_NODE_TYPES.ObjectExpression) {
        return decoratorArgument.properties
            .filter((x) => x?.key
            ?.name === "path")
            .map((x) => x.value.raw);
    }
    return [];
};
exports.parsePathParts = parsePathParts;
/**
 * nestjs allows for paths with _+?()*
 * this rule doesn't support parsing those so we'll just pass
 */
const hasPathPartsAnyRegexParams = (pathPartsToCheck) => {
    // prettier-ignore
    // eslint-disable-next-line no-useless-escape
    const specialCharacterRegex = /(dareslint__skip|\*|\+|\?|\(|\)|_)/; //new RegExp("([\?\+\*\_\(\)])")
    return pathPartsToCheck.some((pathPart) => {
        return specialCharacterRegex.test(pathPart);
    });
};
exports.hasPathPartsAnyRegexParams = hasPathPartsAnyRegexParams;
/**
 * Checks if there is a matching path part for the paramName
 * @param paramName
 * @param pathPartsToCheck
 * @returns
 */
const isParameterNameIncludedInAPathPart = (paramName, pathPartsToCheck) => {
    return pathPartsToCheck.some((pathPart) => {
        return (
        // note to reader: this might be better as a regex. feel free to open a pr!
        pathPart === `":${paramName}"` ||
            pathPart === `':${paramName}'` ||
            pathPart.includes(`/:${paramName}/`) ||
            pathPart.includes(`/:${paramName}"`) ||
            pathPart.includes(`":${paramName}/`) ||
            pathPart.includes(`/:${paramName}'`) ||
            pathPart.includes(`':${paramName}/`));
    });
};
exports.isParameterNameIncludedInAPathPart = isParameterNameIncludedInAPathPart;
const shouldTrigger = (decorator) => {
    if (!decorator) {
        return {
            hasColonInName: false,
            paramNameNotMatchedInPath: false,
        };
    }
    // grab the param name
    const paramName = decorator.expression
        ?.arguments[0]?.value;
    // if there's no param name get out of here
    if (!paramName || paramName === "") {
        return {
            hasColonInName: false,
            paramNameNotMatchedInPath: false,
        };
    }
    // param names don't need the colon
    if (paramName.startsWith(":")) {
        return {
            hasColonInName: true,
            paramNameNotMatchedInPath: false,
        };
    }
    let pathPartsToCheck = [];
    // grab any controller path parts
    // eslint-disable-next-line @typescript-eslint/non-nullable-type-assertion-style
    const controllerDecorator = decorator.parent?.parent?.parent?.parent
        ?.parent?.decorators?.find((d) => {
        return (d.expression
            .callee?.name === "Controller");
    });
    pathPartsToCheck = pathPartsToCheck.concat((0, exports.parsePathParts)(controllerDecorator));
    // grab any api method path parts from method decorator
    const methodDefinition = decorator.parent?.parent
        ?.parent;
    // eslint-disable-next-line @typescript-eslint/non-nullable-type-assertion-style
    const methodDecorator = methodDefinition?.decorators?.find((d) => {
        return nestRequestMethodDecoratorNames.has(d.expression
            .callee?.name);
    });
    pathPartsToCheck = pathPartsToCheck.concat((0, exports.parsePathParts)(methodDecorator));
    const shouldIgnoreThisSetOfRoutes = 
    // is a template literal argument
    // is an identifier argument
    (0, exports.hasPathPartsAnyRegexParams)(pathPartsToCheck);
    if (shouldIgnoreThisSetOfRoutes) {
        return {
            hasColonInName: false,
            paramNameNotMatchedInPath: false,
        };
    }
    // check that the param name is in one path part
    return {
        hasColonInName: false,
        paramNameNotMatchedInPath: !(0, exports.isParameterNameIncludedInAPathPart)(paramName, pathPartsToCheck),
    };
};
exports.shouldTrigger = shouldTrigger;
const rule = (0, createRule_1.createRule)({
    name: "param-decorator-name-matches-route-param",
    meta: {
        docs: {
            description: 'Param decorators with a name parameter e.g. Param("myvar") should match a specified route parameter - e.g. Get(":myvar")',
            requiresTypeChecking: false,
        },
        messages: {
            paramIdentifierDoesntNeedColon: "You don't need to specify the colon (:) in a Param decorator",
            paramIdentifierShouldMatch: 'Param decorators with identifiers e.g. Param("myvar") should match a specified route parameter - e.g. Get(":myvar")',
        },
        schema: [],
        hasSuggestions: false,
        type: "suggestion",
    },
    defaultOptions: [],
    create(context) {
        return {
            // eslint-disable-next-line @typescript-eslint/naming-convention
            Decorator(node) {
                if (node.expression
                    ?.callee?.name !== "Param") {
                    return;
                }
                // eslint-disable-next-line @typescript-eslint/naming-convention
                const result = (0, exports.shouldTrigger)(node);
                if (result.paramNameNotMatchedInPath) {
                    context.report({
                        node: node,
                        messageId: "paramIdentifierShouldMatch",
                    });
                }
                if (result.hasColonInName) {
                    context.report({
                        node: node,
                        messageId: "paramIdentifierDoesntNeedColon",
                    });
                }
            },
        };
    },
});
exports.default = rule;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGFyYW1EZWNvcmF0b3JOYW1lTWF0Y2hlc1JvdXRlUGFyYW0uanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvcnVsZXMvcGFyYW1EZWNvcmF0b3JOYW1lTWF0Y2hlc1JvdXRlUGFyYW0vcGFyYW1EZWNvcmF0b3JOYW1lTWF0Y2hlc1JvdXRlUGFyYW0udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsa0RBQWtEO0FBQ2xELG9EQUFrRDtBQUNsRCx1REFBa0Q7QUFPbEQsTUFBTSwrQkFBK0IsR0FBRyxJQUFJLEdBQUcsQ0FBQztJQUM1QyxLQUFLO0lBQ0wsTUFBTTtJQUNOLEtBQUs7SUFDTCxRQUFRO0lBQ1IsT0FBTztJQUNQLFNBQVM7SUFDVCxNQUFNO0lBQ04sS0FBSztDQUNSLENBQUMsQ0FBQztBQUVJLE1BQU0sY0FBYyxHQUFHLENBQUMsU0FBNkIsRUFBWSxFQUFFO0lBQ3RFLE1BQU0saUJBQWlCLEdBQUksU0FBUyxFQUFFLFVBQXNDO1FBQ3hFLEVBQUUsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBRW5CLElBQ0ksaUJBQWlCLEVBQUUsSUFBSSxLQUFLLGdCQUFRLENBQUMsY0FBYyxDQUFDLGVBQWU7UUFDbkUsaUJBQWlCLEVBQUUsSUFBSSxLQUFLLGdCQUFRLENBQUMsY0FBYyxDQUFDLFVBQVUsRUFDaEU7UUFDRSxPQUFPLENBQUMsaUJBQWlCLENBQUMsQ0FBQztLQUM5QjtJQUVELElBQUksaUJBQWlCLEVBQUUsSUFBSSxLQUFLLGdCQUFRLENBQUMsY0FBYyxDQUFDLE9BQU8sRUFBRTtRQUM3RCxPQUFPLENBQUMsaUJBQWlCLENBQUMsR0FBRyxDQUFDLENBQUM7S0FDbEM7SUFDRCxJQUFJLGlCQUFpQixFQUFFLElBQUksS0FBSyxnQkFBUSxDQUFDLGNBQWMsQ0FBQyxlQUFlLEVBQUU7UUFDckUsT0FBTyxpQkFBaUIsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUNqQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUUs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