"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.needsEnumNameMatchingEnumType = exports.hasEnumSpecifiedCorrectly = void 0;
const utils_1 = require("@typescript-eslint/utils");
const createRule_1 = require("../../utils/createRule");
const typedTokenHelpers_1 = require("../../utils/typedTokenHelpers");
const enumTestResultModel_1 = require("./enumTestResultModel");
const noChangesRequiredResult = new enumTestResultModel_1.EnumTestResultModel({
    needsEnumAdded: false,
    needsEnumNameAdded: false,
    needsEnumNameToMatchEnumType: false,
    needsTypeRemoved: false,
});
const hasEnumSpecifiedCorrectly = (node, isEnumType) => {
    // is this an enum
    if (!isEnumType) {
        return noChangesRequiredResult;
    }
    // is this decorated with api documentation
    const decorators = typedTokenHelpers_1.typedTokenHelpers.getDecoratorsNamed(node, ["ApiPropertyOptional", "ApiProperty"]);
    if (decorators.length === 0) {
        return noChangesRequiredResult;
    }
    // check if there is an enum property in the provided options (enums should specify the enum property)
    const firstArgument = decorators[0].expression
        .arguments[0];
    if (!firstArgument) {
        return new enumTestResultModel_1.EnumTestResultModel({
            needsEnumAdded: true,
            needsEnumNameAdded: true,
            needsEnumNameToMatchEnumType: false,
            needsTypeRemoved: false,
        });
    }
    const enumProperty = firstArgument.properties.find((p) => p.key.name ===
        "enum");
    // check if there is a type: property in the provided options (enums shouldn't specify type)
    const hasTypeProperty = firstArgument.properties.find((p) => p.key.name ===
        "type") !== undefined;
    // check if there is an enumName: property in the provided options (enums should specify a name)
    const enumNameProperty = firstArgument.properties.find((p) => p.key.name ===
        "enumName");
    return new enumTestResultModel_1.EnumTestResultModel({
        needsEnumAdded: enumProperty === undefined,
        needsEnumNameAdded: enumNameProperty === undefined,
        needsEnumNameToMatchEnumType: (0, exports.needsEnumNameMatchingEnumType)(enumNameProperty, enumProperty),
        needsTypeRemoved: hasTypeProperty,
    });
};
exports.hasEnumSpecifiedCorrectly = hasEnumSpecifiedCorrectly;
const needsEnumNameMatchingEnumType = (enumNameProperty, enumProperty) => {
    // if enum props aren't specified we don't care about this scenario
    if (enumNameProperty === undefined || enumProperty === undefined) {
        return false;
    }
    const isEnumNameMatchingEnumType = enumNameProperty.value.value ===
        enumProperty.value.name;
    return !isEnumNameMatchingEnumType;
};
exports.needsEnumNameMatchingEnumType = needsEnumNameMatchingEnumType;
const rule = (0, createRule_1.createRule)({
    name: "api-enum-property-best-practices",
    meta: {
        docs: {
            description: "Enums should use the best practices for api documentation",
            requiresTypeChecking: false,
        },
        messages: {
            needsEnumNameAdded: `Properties with enum should also specify an enumName property to keep generated models clean`,
            needsTypeRemoved: `Properties with enum should not specify a type property`,
            enumNameShouldMatchType: `The enumName should match the enum type provided`,
        },
        schema: [],
        hasSuggestions: false,
        type: "suggestion",
    },
    defaultOptions: [],
    create(context) {
        //const globalScope = context.getScope();
        const parserServices = utils_1.ESLintUtils.getParserServices(context);
        const typeChecker = parserServices.program.getTypeChecker();
        return {
            // eslint-disable-next-line @typescript-eslint/naming-convention
            PropertyDefinition(node) {
                const mappedNode = parserServices.esTreeNodeToTSNodeMap.get(node);
                const objectType = typeChecker.getTypeAtLocation(mappedNode);
                const isEnumType = typedTokenHelpers_1.typedTokenHelpers.isEnumType(objectType);
                const result = (0, exports.hasEnumSpecifiedCorrectly)(node, isEnumType);
                if (result.needsEnumNameAdded) {
                    context.report({
                        node: node,
                        messageId: "needsEnumNameAdded",
                    });
                }
                if (result.needsTypeRemoved) {
                    context.report({
                        node: node,
                        messageId: "needsTypeRemoved",
                    });
                }
                if (result.needsEnumNameToMatchEnumType) {
                    context.report({
                        node: node,
                        messageId: "enumNameShouldMatchType",
                    });
                }
            },
        };
    },
});
exports.default = rule;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXBpRW51bVByb3BlcnR5QmVzdFByYWN0aWNlcy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9ydWxlcy9hcGlFbnVtUHJvcGVydHlCZXN0UHJhY3RpY2VzL2FwaUVudW1Qcm9wZXJ0eUJlc3RQcmFjdGljZXMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsb0RBQStEO0FBQy9ELHVEQUFrRDtBQUNsRCxxRUFBZ0U7QUFDaEUsK0RBQTBEO0FBRTFELE1BQU0sdUJBQXVCLEdBQUcsSUFBSSx5Q0FBbUIsQ0FBQztJQUNwRCxjQUFjLEVBQUUsS0FBSztJQUNyQixrQkFBa0IsRUFBRSxLQUFLO0lBQ3pCLDRCQUE0QixFQUFFLEtBQUs7SUFDbkMsZ0JBQWdCLEVBQUUsS0FBSztDQUMxQixDQUFDLENBQUM7QUFFSSxNQUFNLHlCQUF5QixHQUFHLENBQ3JDLElBQW1CLEVBQ25CLFVBQW1CLEVBQ0EsRUFBRTtJQUNyQixrQkFBa0I7SUFDbEIsSUFBSSxDQUFDLFVBQVUsRUFBRTtRQUNiLE9BQU8sdUJBQXVCLENBQUM7S0FDbEM7SUFFRCwyQ0FBMkM7SUFDM0MsTUFBTSxVQUFVLEdBQUcscUNBQWlCLENBQUMsa0JBQWtCLENBQ25ELElBQW1DLEVBQ25DLENBQUMscUJBQXFCLEVBQUUsYUFBYSxDQUFDLENBQ3pDLENBQUM7SUFFRixJQUFJLFVBQVUsQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO1FBQ3pCLE9BQU8sdUJBQXVCLENBQUM7S0FDbEM7SUFFRCxzR0FBc0c7SUFDdEcsTUFBTSxhQUFhLEdBQUksVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLFVBQXNDO1NBQ3RFLFNBQVMsQ0FBQyxDQUFDLENBQThCLENBQUM7SUFDL0MsSUFBSSxDQUFDLGFBQWEsRUFBRTtRQUNoQixPQUFPLElBQUkseUNBQW1CLENBQUM7WUFDM0IsY0FBYyxFQUFFLElBQUk7WUFDcEIsa0JBQWtCLEVBQUUsSUFBSTtZQUN4Qiw0QkFBNEIsRUFBRSxLQUFLO1lBQ25DLGdCQUFnQixFQUFFLEtBQUs7U0FDMUIsQ0FBQyxDQUFDO0tBQ047SUFFRCxNQUFNLFlBQVksR0FBRyxhQUFhLENBQUMsVUFBVSxDQUFDLElBQUksQ0FDOUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUNBLENBQXVCLENBQUMsR0FBMkIsQ0FBQyxJQUFJO1FBQzFELE1BQU0sQ0FDYixDQUFDO0lBRUYsNEZBQTRGO0lBQzVGLE1BQU0sZUFBZSxHQUNqQixhQUFhLENBQUMsVUFBVSxDQUFDLElBQUksQ0FDekIsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUNBLENBQXVCLENBQUMsR0FBMkIsQ0FBQyxJQUFJO1FBQzFELE1BQU0sQ0FDYixLQUFLLFNBQVMsQ0FBQztJQUVwQixnR0FBZ0c7SUFDaEcsTUFBTSxnQkFBZ0IsR0FBRyxhQUFhLENBQUMsVUFBVSxDQUFDLElBQUksQ0FDbEQsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUNBLENBQXVCLENBQUMsR0FBMkIsQ0FBQyxJQUFJO1FBQzFELFVBQVUsQ0FDakIsQ0FBQztJQUNGLE9BQU8sSUFBSSx5Q0FBbUIsQ0FBQztRQUMzQixjQUFjLEVBQUUsWUFBWSxLQUFLLFNBQVM7UUFDMUMsa0JBQWtCLEVBQUUsZ0JBQWdCLEtBQUssU0FBUztRQUNsRCw0QkFBNEIsRUFBRSxJQUFBLHFDQUE2QixFQUN2RCxnQkFBcUMsRUFDckMsWUFBaUMsQ0FDcEM7UUFDRCxnQkFBZ0IsRUFBRSxlQUFlO0tBQ3BDLENBQUMsQ0FBQztBQUNQLENBQUMsQ0FBQztBQTVEVyxRQUFBLHlCQUF5Qiw2QkE0RHBDO0FBRUssTUFBTSw2QkFBNkIsR0FBRyxDQUN6QyxnQkFBbUMsRUFDbkMsWUFBK0IsRUFDeEIsRUFBRTtJQUNULG1FQUFtRTtJQUNuRSxJQUFJLGdCQUFnQixLQUFLLFNBQVMsSUFBSSxZQUFZLEtBQUssU0FBUyxFQUFFO1FBQzlELE9BQU8sS0FBSyxDQUFDO0tBQ2hCO0lBRUQsTUFBTSwwQkFBMEIsR0FDM0IsZ0JBQWdCLENBQUMsS0FBMEIsQ0FBQyxLQUFLO1FBQ2pELFlBQVksQ0FBQyxLQUE2QixDQUFDLElBQUksQ0FBQztJQUVyRCxPQUFPLENBQUMsMEJBQTBCLENBQUM7QUFDdkMsQ0FBQyxDQUFDO0FBZFcsUUFBQSw2QkFBNkIsaUNBY3hDO0FBRUYsTUFBTSxJQUFJLEdBQUcsSUFBQSx1QkFBVSxFQUdyQjtJQUNFLElBQUksRUFBRSxrQ0FBa0M7SUFDeEMsSUFBSSxFQUFFO1FBQ0YsSUFBSSxFQUFFO1lBQ0YsV0FBVyxFQUNQLDJEQUEyRDtZQUUvRCxvQkFBb0IsRUFBRSxLQUFLO1NBQzlCO1FBQ0QsUUFBUSxFQUFFO1lBQ04sa0JBQWtCLEVBQUUsOEZBQThGO1lBQ2xILGdCQUFnQixFQUFFLHlEQUF5RDtZQUMzRSx1QkFBdUIsRUFBRSxrREFBa0Q7U0FDOUU7UUFDRCxNQUFNLEVBQUUsRUFBRTtRQUNWLGNBQWMsRUFBRSxLQUFLO1FBQ3JCLElBQUksRUFBRSxZQUFZO0tBQ3JCO0lBQ0QsY0FBYyxFQUFFLEVBQUU7SUFFbEIsTUFBTSxDQUFDLE9BQU87UUFDVix5Q0FBeUM7UUFDekMsTUFBTSxjQUFjLEdBQUcsbUJBQVcsQ0FBQyxpQkFBaUIsQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUM5RCxNQUFNLFdBQVcsR0FBRyxjQUFjLENBQUMsT0FBTyxDQUFDLGNBQWMsRUFBRSxDQUFDO1FBRTVELE9BQU87WUFDSCxnRUFBZ0U7WUFDaEUsa0JBQWtCLENBQUMsSUFBbUI7Z0JBQ2xDLE1BQU0sVUFBVSxHQUNaLGNBQWMsQ0FBQyxxQkFBcUIsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUM7Z0JBQ25ELE1BQU0sVUFBVSxHQUFHLFdBQVcsQ0FBQyxpQkFBaUIsQ0FBQyxVQUFVLENBQUMsQ0FBQztnQkFDN0QsTUFBTSxVQUFVLEdBQUcscUNBQWlCLENBQUMsVUFBVSxDQUFDLFVBQVUsQ0FBQyxDQUFDO2dCQUU1RCxNQUFNLE1BQU0sR0FBRyxJQUFBLGlDQUF5QixFQUFDLElBQUksRUFBRSxVQUFVLENBQUMsQ0FBQztnQkFFM0QsSUFBSSxNQUFNLENBQUMsa0JBQWtCLEVBQUU7b0JBQzNCLE9BQU8sQ0FBQyxNQUFNLENBQUM7d0JBQ1gsSUFBSSxFQUFFLElBQUk7d0JBQ1YsU0FBUyxFQUFFLG9CQUFvQjtxQkFDbEMsQ0FBQyxDQUFDO2lCQUNOO2dCQUNELElBQUksTUFBTSxDQUFDLGdCQUFnQixFQUFFO29CQUN6QixPQUFPLENBQUMsTUFBTSxDQUFDO3dCQUNYLElBQUksRUFBRSxJQUFJO3dCQUNWLFNBQVMsRUFBRSxrQkFBa0I7cUJBQ2hDLENBQUMsQ0FBQztpQkFDTjtnQkFDRCxJQUFJLE1BQU0sQ0FBQyw0QkFBNEIsRUFBRTtvQkFDckMsT0FBTyxDQUFDLE1BQU0sQ0FBQzt3QkFDWCxJQUFJLEVBQUUsSUFBSTt3QkFDVixTQUFTLEVBQUUseUJBQXlCO3FCQUN2QyxDQUFDLENBQUM7aUJBQ047WUFDTCxDQUFDO1NBQ0osQ0FBQztJQUNOLENBQUM7Q0FDSixDQUFDLENBQUM7QUFFSCxrQkFBZSxJQUFJLENBQUMifQ==