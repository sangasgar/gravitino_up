"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const type_utils_1 = require("@typescript-eslint/type-utils");
const ast_1 = require("../../utils/ast");
const createRule_1 = require("../../utils/createRule");
const typedTokenHelpers_1 = require("../../utils/typedTokenHelpers");
const rule = (0, createRule_1.createRule)({
    name: "all-properties-have-explicit-defined",
    meta: {
        docs: {
            description: "Enforce all properties have an explicit defined status decorator",
            recommended: "error",
            requiresTypeChecking: true,
        },
        messages: {
            "missing-is-defined-decorator": "Non-optional properties must have a decorator that checks the value is defined (for example: @IsDefined())",
            "missing-is-optional-decorator": "Optional properties must have @IsOptional() decorator",
            "conflicting-defined-decorators": "Properties can have @IsDefined() or @IsOptional() but not both",
        },
        type: "problem",
        schema: [],
    },
    defaultOptions: [],
    create: function (context) {
        const service = utils_1.ESLintUtils.getParserServices(context);
        const checker = service.program.getTypeChecker();
        return {
            // eslint-disable-next-line @typescript-eslint/naming-convention
            ClassDeclaration(node) {
                const propertyDefinitionsWithDecoratorsStatus = [];
                let withDecoratorCount = 0;
                const propertyDefinitions = (0, ast_1.getPropertiesDefinitions)(node);
                // for each property in the class
                for (const propertyDefinition of propertyDefinitions) {
                    // check for the optional or defined decorators, or any class-validator decorator
                    const decoratorsStatus = getDecoratorsStatus(propertyDefinition);
                    propertyDefinitionsWithDecoratorsStatus.push([
                        propertyDefinition,
                        decoratorsStatus,
                    ]);
                    // It doesn't make sense to have both @IsDefined and @IsOptional decorators
                    if (decoratorsStatus.hasIsDefinedDecorator &&
                        decoratorsStatus.hasIsOptionalDecorator) {
                        context.report({
                            node: propertyDefinition,
                            messageId: "conflicting-defined-decorators",
                        });
                    }
                    if (decoratorsStatus.hasIsDefinedDecorator ||
                        decoratorsStatus.hasTypeCheckingDecorator ||
                        decoratorsStatus.hasIsOptionalDecorator) {
                        withDecoratorCount++;
                    }
                }
                if (withDecoratorCount > 0) {
                    for (const [propertyDefinition, decoratorsStatus,] of propertyDefinitionsWithDecoratorsStatus) {
                        // if there's no type available we can't check if it's optional
                        if (!propertyDefinition.typeAnnotation) {
                            continue;
                        }
                        // get the type of the property
                        const type = getType(propertyDefinition.typeAnnotation.typeAnnotation, service, checker);
                        // if the type is nullable, it should be optional
                        if (propertyDefinition.optional ||
                            (0, type_utils_1.isNullableType)(type)) {
                            if (!decoratorsStatus.hasIsOptionalDecorator) {
                                context.report({
                                    node: propertyDefinition,
                                    messageId: "missing-is-optional-decorator",
                                });
                            }
                        }
                        else {
                            if (!decoratorsStatus.hasIsDefinedDecorator &&
                                !decoratorsStatus.hasTypeCheckingDecorator) {
                                context.report({
                                    node: propertyDefinition,
                                    messageId: "missing-is-defined-decorator",
                                });
                            }
                        }
                    }
                }
            },
        };
    },
});
exports.default = rule;
function getType(typeNode, service, checker) {
    const tsNode = service.esTreeNodeToTSNodeMap.get(typeNode);
    const type = checker.getTypeAtLocation(tsNode);
    return type;
}
function getDecoratorsStatus(propertyDefinition) {
    let hasIsDefinedDecorator = false;
    let hasTypeCheckingDecorator = false;
    let hasIsOptionalDecorator = false;
    const program = typedTokenHelpers_1.typedTokenHelpers.getRootProgram(propertyDefinition);
    if (propertyDefinition.decorators) {
        for (const decorator of propertyDefinition.decorators) {
            if (decorator.expression.type === utils_1.AST_NODE_TYPES.CallExpression &&
                decorator.expression.callee.type === utils_1.AST_NODE_TYPES.Identifier) {
                // if this is not a class-validator decorator, skip it (this avoids name conflicts with decorators from other libraries)
                if (!typedTokenHelpers_1.typedTokenHelpers.decoratorIsClassValidatorDecorator(program, decorator)) {
                    continue;
                }
                // We care if the decorator is a validation decorator like IsString etc for checks later
                if (decorator.expression.callee.name !== "IsDefined" &&
                    decorator.expression.callee.name !== "IsOptional") {
                    hasTypeCheckingDecorator = true;
                }
                // otherwise check if it is isDefined or isOptional, we will use this later
                if (decorator.expression.callee.name === "IsDefined") {
                    hasIsDefinedDecorator = true;
                }
                if (decorator.expression.callee.name === "IsOptional") {
                    hasIsOptionalDecorator = true;
                }
            }
        }
    }
    return {
        hasIsDefinedDecorator,
        hasTypeCheckingDecorator,
        hasIsOptionalDecorator,
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWxsUHJvcGVydGllc0hhdmVFeHBsaWNpdERlZmluZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvcnVsZXMvYWxsUHJvcGVydGllc0hhdmVFeHBsaWNpdERlZmluZWQvYWxsUHJvcGVydGllc0hhdmVFeHBsaWNpdERlZmluZWQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSxvREFLa0M7QUFDbEMsOERBQTZEO0FBQzdELHlDQUF5RDtBQUN6RCx1REFBa0Q7QUFFbEQscUVBQWdFO0FBR2hFLE1BQU0sSUFBSSxHQUFHLElBQUEsdUJBQVUsRUFLckI7SUFDRSxJQUFJLEVBQUUsc0NBQXNDO0lBQzVDLElBQUksRUFBRTtRQUNGLElBQUksRUFBRTtZQUNGLFdBQVcsRUFDUCxrRUFBa0U7WUFDdEUsV0FBVyxFQUFFLE9BQTZCO1lBQzFDLG9CQUFvQixFQUFFLElBQUk7U0FDN0I7UUFDRCxRQUFRLEVBQUU7WUFDTiw4QkFBOEIsRUFDMUIsNEdBQTRHO1lBQ2hILCtCQUErQixFQUMzQix1REFBdUQ7WUFDM0QsZ0NBQWdDLEVBQzVCLGdFQUFnRTtTQUN2RTtRQUNELElBQUksRUFBRSxTQUFTO1FBQ2YsTUFBTSxFQUFFLEVBQUU7S0FDYjtJQUNELGNBQWMsRUFBRSxFQUFFO0lBQ2xCLE1BQU0sRUFBRSxVQUFVLE9BQU87UUFDckIsTUFBTSxPQUFPLEdBQUcsbUJBQVcsQ0FBQyxpQkFBaUIsQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUV2RCxNQUFNLE9BQU8sR0FBRyxPQUFPLENBQUMsT0FBTyxDQUFDLGNBQWMsRUFBRSxDQUFDO1FBQ2pELE9BQU87WUFDSCxnRUFBZ0U7WUFDaEUsZ0JBQWdCLENBQUMsSUFBK0I7Z0JBQzVDLE1BQU0sdUNBQXVDLEdBR3ZDLEVBQUUsQ0FBQztnQkFDVCxJQUFJLGtCQUFrQixHQUFHLENBQUMsQ0FBQztnQkFDM0IsTUFBTSxtQkFBbUIsR0FBRyxJQUFBLDhCQUF3QixFQUFDLElBQUksQ0FBQyxD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