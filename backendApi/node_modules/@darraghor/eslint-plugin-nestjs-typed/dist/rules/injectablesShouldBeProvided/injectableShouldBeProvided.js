"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const createRule_1 = require("../../utils/createRule");
const fileEnumerationWrapper_1 = __importDefault(require("../../utils/files/fileEnumerationWrapper"));
const nestProvidedInjectableMapper_1 = __importDefault(require("../../utils/nestModules/nestProvidedInjectableMapper"));
const typedTokenHelpers_1 = require("../../utils/typedTokenHelpers");
// eslint-disable-next-line @typescript-eslint/no-explicit-any
let listOfPotentialNestModuleFiles;
let nestModuleMap;
const findModuleMapping = (classNAme, propertyName, nestModuleMap) => {
    for (const entry of nestModuleMap.values()) {
        if (entry[propertyName].has(classNAme)) {
            return entry;
        }
    }
    return undefined;
};
// super fragile types but whatevs
const checkNode = (node, decoratorName, propertyName, messageId, context) => {
    if (nestProvidedInjectableMapper_1.default.isNestInjectableThatIsNeverProvided(node)) {
        return;
    }
    if (typedTokenHelpers_1.typedTokenHelpers.nodeHasDecoratorsNamed(node, [decoratorName])) {
        const name = node.id?.name;
        if (!name) {
            return;
        }
        const foundMap = findModuleMapping(name, propertyName, nestModuleMap);
        if (foundMap) {
            return;
        }
        // couldn't find map so error
        context.report({
            node: node,
            messageId: messageId,
        });
    }
};
function initializeModuleMappings(sourcePath, filterFromPaths, context) {
    const mappedSourceDirectory = nestProvidedInjectableMapper_1.default.detectDirectoryToScanForFiles(sourcePath, process.cwd());
    listOfPotentialNestModuleFiles = fileEnumerationWrapper_1.default.enumerateFiles(mappedSourceDirectory, [".ts"], filterFromPaths);
    nestModuleMap = nestProvidedInjectableMapper_1.default.parseFileList(listOfPotentialNestModuleFiles, context);
}
const defaultOptions = [
    {
        src: ["src/**/*.ts"],
        filterFromPaths: ["dist", "node_modules", ".test.", ".spec."],
    },
];
const rule = (0, createRule_1.createRule)({
    name: "injectable-should-be-provided",
    meta: {
        docs: {
            description: "Public api methods should have documentation",
            requiresTypeChecking: false,
        },
        messages: {
            injectableInModule: `Classes marked as Injectable must be added to a module's providers. If you added it already but this error still shows in your editor, please change one character in the injectable file to poke your eslint plugin.`,
            controllersInModule: `Classes marked as Controller must be added to a module's controllers. If you added it already but this error still shows in your editor, please change one character in the controller file to poke your eslint plugin.`,
        },
        schema: [
            {
                type: "object",
                properties: {
                    src: {
                        description: "files/paths to be analyzed (only for provided injectable or controller)",
                        type: "array",
                        minItems: 1,
                        items: {
                            type: "string",
                            minLength: 1,
                        },
                    },
                    filterFromPaths: {
                        description: "strings to exclude from checks (only for provided injectable or controller)",
                        type: "array",
                        minItems: 1,
                        items: {
                            type: "string",
                            minLength: 1,
                        },
                    },
                },
            },
        ],
        type: "problem",
    },
    defaultOptions: defaultOptions,
    create(contextWithoutDefaults) {
        const context = contextWithoutDefaults.options &&
            contextWithoutDefaults.options.length > 0
            ? contextWithoutDefaults
            : // only apply the defaults when the user provides no config
                Object.setPrototypeOf({
                    options: defaultOptions,
                }, contextWithoutDefaults);
        const { src, filterFromPaths,
        // ignoreExports = [],
        // missingExports,
        // unusedExports,
         } = context.options[0] || {};
        if (nestModuleMap === undefined || nestModuleMap.size === 0) {
            initializeModuleMappings(src[0], filterFromPaths, context);
        }
        return {
            // eslint-disable-next-line @typescript-eslint/naming-convention
            ClassDeclaration(node) {
                checkNode(node, "Injectable", "providers", "injectableInModule", context);
                checkNode(node, "Controller", "controllers", "controllersInModule", context);
            },
            // eslint-disable-next-line @typescript-eslint/naming-convention
            "Program:exit"() {
                // map the source to a mapping thing
                // if not undefined set it to the mapping set
                const mappedProvidedInjectables = nestProvidedInjectableMapper_1.default.mapAllProvidedInjectables(context.getSourceCode().ast, context.getFilename());
                if (mappedProvidedInjectables !== null) {
                    nestModuleMap.set(mappedProvidedInjectables[0], mappedProvidedInjectables[1]);
                }
            },
        };
    },
});
exports.default = rule;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5qZWN0YWJsZVNob3VsZEJlUHJvdmlkZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvcnVsZXMvaW5qZWN0YWJsZXNTaG91bGRCZVByb3ZpZGVkL2luamVjdGFibGVTaG91bGRCZVByb3ZpZGVkLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQ0EsdURBQWtEO0FBQ2xELHNHQUE2RTtBQUM3RSx3SEFBZ0c7QUFFaEcscUVBQWdFO0FBSWhFLDhEQUE4RDtBQUM5RCxJQUFJLDhCQUEwQyxDQUFDO0FBQy9DLElBQUksYUFBc0QsQ0FBQztBQVMzRCxNQUFNLGlCQUFpQixHQUFHLENBQ3RCLFNBQWlCLEVBQ2pCLFlBQXlDLEVBQ3pDLGFBQXNELEVBQ2hCLEVBQUU7SUFDeEMsS0FBSyxNQUFNLEtBQUssSUFBSSxhQUFhLENBQUMsTUFBTSxFQUFFLEVBQUU7UUFDeEMsSUFBSSxLQUFLLENBQUMsWUFBWSxDQUFDLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxFQUFFO1lBQ3BDLE9BQU8sS0FBSyxDQUFDO1NBQ2hCO0tBQ0o7SUFDRCxPQUFPLFNBQVMsQ0FBQztBQUNyQixDQUFDLENBQUM7QUFFRixrQ0FBa0M7QUFDbEMsTUFBTSxTQUFTLEdBQUcsQ0FDZCxJQUErQixFQUMvQixhQUEwQyxFQUMxQyxZQUF5QyxFQUN6QyxTQUF1RCxFQUN2RCxPQUtDLEVBQ0gsRUFBRTtJQUNBLElBQ0ksc0NBQTRCLENBQUMsbUNBQW1DLENBQUMsSUFBSSxDQUFDLEVBQ3hFO1FBQ0UsT0FBTztLQUNWO0lBQ0QsSUFBSSxxQ0FBaUIsQ0FBQyxzQkFBc0IsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxhQUFhLENBQUMsQ0FBQyxFQUFFO1FBQ2pFLE1BQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxFQUFFLEVBQUUsSUFBSSxDQUFDO1FBQzNCLElBQUksQ0FBQyxJQUFJLEVBQUU7WUFDUCxPQUFPO1NBQ1Y7UUFDRCxNQUFNLFFBQVEsR0FBRyxpQkFBaUIs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