"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore
const unambiguous = __importStar(require("eslint-module-utils/unambiguous"));
const fs_1 = __importDefault(require("fs"));
const typedTokenHelpers_1 = require("../typedTokenHelpers");
const nestModuleAstParser_1 = require("./nestModuleAstParser");
const nestProviderAstParser_1 = require("./nestProviderAstParser");
const implementsForInjectablesThatAreNotProvided = new Set([
    "CanActivate",
    "NestInterceptor",
    "PipeTransform",
    "NestMiddleware", //(isMiddleware)
]);
const NestProvidedInjectableMapper = {
    detectDirectoryToScanForFiles(sourceGlob, currentWorkingDirectory) {
        if (sourceGlob && typeof sourceGlob === "string") {
            return [sourceGlob];
        }
        if (sourceGlob && Array.isArray(sourceGlob)) {
            return sourceGlob;
        }
        console.debug("Injectables should be provided is using cwd for scanning. Consider configuring it in eslintrc.", { currentWorkingDirectory });
        return [currentWorkingDirectory];
    },
    parseFileList(files, 
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    context) {
        const moduleMaps = new Map();
        files
            .map((f) => {
            const fileContents = NestProvidedInjectableMapper.readFileContents(f.filename);
            const fileAstString = typedTokenHelpers_1.typedTokenHelpers.parseStringToAst(fileContents, f.filename, context);
            return NestProvidedInjectableMapper.mapAllProvidedInjectables(fileAstString, f.filename);
        })
            // eslint-disable-next-line @typescript-eslint/unbound-method
            .filter(NestProvidedInjectableMapper.notEmpty)
            .forEach((m) => moduleMaps.set(m[0], m[1]));
        return moduleMaps;
    },
    notEmpty(value) {
        if (value === null || value === undefined)
            return false;
        return true;
    },
    readFileContents(path) {
        return fs_1.default.readFileSync(path, { encoding: "utf8" });
    },
    isNestInjectableThatIsNeverProvided(node) {
        for (const implementsClass of node.implements || []) {
            if (implementsForInjectablesThatAreNotProvided.has(implementsClass.expression.name)) {
                return true;
            }
        }
        return false;
    },
    mapAllProvidedInjectables(ast, path) {
        try {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            if (
            // eslint-disable-next-line no-constant-condition, @typescript-eslint/ban-ts-comment
            // @ts-ignore
            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call
            !unambiguous.isModule(ast)) {
                return null;
            }
            // This does too much and should probably be split up
            // i also assume you would never have multiple of providers, controllers or modules in a file
            // dangerous assumption i guess. i have never seen this done before though.
            // set up the response model
            let nestModuleMap = null;
            // Is this a module?
            const foundNestModuleClass = nestModuleAstParser_1.nestModuleAstParser.findNestModuleClass(ast);
            if (foundNestModuleClass) {
                nestModuleMap = nestModuleAstParser_1.nestModuleAstParser.mapNestModuleDecorator(foundNestModuleClass, path);
                return nestModuleMap;
            }
            // or is this a custom provider that would provide an instance of the class?
            // if it is we map the itentifier it "provide"s. This will only work if it's an identifier
            // it can't be provider for a string literal "provide".
            const foundProviderDeclaration = nestProviderAstParser_1.nestProviderAstParser.findNestProviderVariableDeclaration(ast);
            const provideProperty = nestProviderAstParser_1.nestProviderAstParser.findProvideProperty(foundProviderDeclaration, "provide");
            if (provideProperty) {
                nestModuleMap = nestProviderAstParser_1.nestProviderAstParser.mapNestProviderObject(provideProperty, path);
            }
            return nestModuleMap;
        }
        catch (error) {
            console.error("parse error:", path, error);
            // m.errors.push(error);
            // return m; // can't continue
            return null;
        }
    },
};
exports.default = NestProvidedInjectableMapper;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmVzdFByb3ZpZGVkSW5qZWN0YWJsZU1hcHBlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy91dGlscy9uZXN0TW9kdWxlcy9uZXN0UHJvdmlkZWRJbmplY3RhYmxlTWFwcGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDQSw2REFBNkQ7QUFDN0QsYUFBYTtBQUNiLDZFQUErRDtBQUUvRCw0Q0FBb0I7QUFDcEIsNERBQXVEO0FBR3ZELCtEQUEwRDtBQUMxRCxtRUFBOEQ7QUFFOUQsTUFBTSwwQ0FBMEMsR0FBRyxJQUFJLEdBQUcsQ0FBQztJQUN2RCxhQUFhO0lBQ2IsaUJBQWlCO0lBQ2pCLGVBQWU7SUFDZixnQkFBZ0IsRUFBRSxnQkFBZ0I7Q0FDckMsQ0FBQyxDQUFDO0FBQ0gsTUFBTSw0QkFBNEIsR0FBRztJQUNqQyw2QkFBNkIsQ0FDekIsVUFBeUMsRUFDekMsdUJBQStCO1FBRS9CLElBQUksVUFBVSxJQUFJLE9BQU8sVUFBVSxLQUFLLFFBQVEsRUFBRTtZQUM5QyxPQUFPLENBQUMsVUFBVSxDQUFDLENBQUM7U0FDdkI7UUFFRCxJQUFJLFVBQVUsSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQyxFQUFFO1lBQ3pDLE9BQU8sVUFBVSxDQUFDO1NBQ3JCO1FBQ0QsT0FBTyxDQUFDLEtBQUssQ0FDVCxnR0FBZ0csRUFDaEcsRUFBQyx1QkFBdUIsRUFBQyxDQUM1QixDQUFDO1FBQ0YsT0FBTyxDQUFDLHVCQUF1QixDQUFDLENBQUM7SUFDckMsQ0FBQztJQUNELGFBQWEsQ0FDVCxLQUFpQjtJQUNqQiw4REFBOEQ7SUFDOUQsT0FBbUQ7UUFFbkQsTUFBTSxVQUFVLEdBQUcsSUFBSSxHQUFHLEVBQXNDLENBQUM7UUFDakUsS0FBSzthQUNBLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFO1lBQ1AsTUFBTSxZQUFZLEdBQ2QsNEJBQTRCLENBQUMsZ0JB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